import os

# Configuration
PROJECT_NAME = "sensor_diagnostic"
MAIN_FILE_NAME = "main.c"

# CMake Configuration (Standard ESP-IDF)
CMAKE_PROJECT_TXT = f"""cmake_minimum_required(VERSION 3.16)
include($ENV{{IDF_PATH}}/tools/cmake/project.cmake)
project({PROJECT_NAME})
"""

CMAKE_MAIN_TXT = """idf_component_register(SRCS "main.c"
                    INCLUDE_DIRS ".")
"""

# The Diagnostic C Code
MAIN_C_SOURCE = """
/**
 * ESP32-P4 Sensor Diagnostic Tool (I2C Scanner + ID Checker)
 * Generated by Gemini
 */

#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2c.h"
#include "esp_log.h"

static const char *TAG = "I2C_DIAG";

// ==========================================================
// CONFIGURATION
// ==========================================================
// ENSURE THESE MATCH YOUR WIRING
#define I2C_MASTER_SCL_IO           8      // GPIO for SCL
#define I2C_MASTER_SDA_IO           7      // GPIO for SDA
#define I2C_MASTER_NUM              0      
#define I2C_MASTER_FREQ_HZ          100000 // Slow speed (100kHz) for maximum reliability during test

// Expected Constants
#define LSM6DSOX_ADDR_1             0x6A
#define LSM6DSOX_ADDR_2             0x6B
#define LSM6DSOX_WHO_AM_I_REG       0x0F
#define LSM6DSOX_EXPECTED_ID        0x6C

#define BMP388_ADDR_1               0x76
#define BMP388_ADDR_2               0x77
#define BMP388_CHIP_ID_REG          0x00
#define BMP388_EXPECTED_ID          0x50


static esp_err_t i2c_master_init(void) {
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_MASTER_FREQ_HZ,
    };
    i2c_param_config(I2C_MASTER_NUM, &conf);
    return i2c_driver_install(I2C_MASTER_NUM, conf.mode, 0, 0, 0);
}

// Helper: Try to read a specific register
esp_err_t read_register(uint8_t addr, uint8_t reg, uint8_t *data) {
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg, true);
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_READ, true);
    i2c_master_read_byte(cmd, data, I2C_MASTER_NACK);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

// Helper: Run a full bus scan
void run_i2c_scanner() {
    ESP_LOGW(TAG, "--- Starting I2C Bus Scan ---");
    int devices_found = 0;
    for (int i = 1; i < 127; i++) {
        i2c_cmd_handle_t cmd = i2c_cmd_link_create();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (i << 1) | I2C_MASTER_WRITE, true);
        i2c_master_stop(cmd);
        esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 50 / portTICK_PERIOD_MS);
        i2c_cmd_link_delete(cmd);

        if (ret == ESP_OK) {
            ESP_LOGI(TAG, "Found device at address: 0x%02X", i);
            devices_found++;
        }
    }
    if (devices_found == 0) {
        ESP_LOGE(TAG, "NO DEVICES FOUND. Check wiring/pullups!");
    } else {
        ESP_LOGW(TAG, "Scan Complete. Found %d device(s).", devices_found);
    }
    ESP_LOGW(TAG, "-----------------------------");
}

// Helper: Dump first 16 registers of a device
void dump_registers(uint8_t addr, const char* name) {
    printf("\\n[Hex Dump for %s (0x%02X)]\\n", name, addr);
    printf("Reg:  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\\n");
    printf("Val:  ");
    for(int i=0; i<16; i++) {
        uint8_t val = 0;
        if(read_register(addr, i, &val) == ESP_OK) {
            printf("%02X ", val);
        } else {
            printf("XX ");
        }
    }
    printf("\\n");
}

void check_sensor(uint8_t addr, uint8_t reg_id, uint8_t expected_id, const char* name) {
    uint8_t id = 0;
    esp_err_t ret = read_register(addr, reg_id, &id);
    
    if (ret == ESP_OK) {
        if (id == expected_id) {
            ESP_LOGI(TAG, "✅ %s IDENTITY VERIFIED (Addr: 0x%02X, ID: 0x%02X)", name, addr, id);
        } else {
            ESP_LOGE(TAG, "❌ %s ID MISMATCH (Addr: 0x%02X). Read: 0x%02X, Expected: 0x%02X", name, addr, id, expected_id);
            ESP_LOGW(TAG, "   (This might be a different sensor model or fake chip)");
        }
        // Dump registers to see if data lines are floating
        dump_registers(addr, name);
    } else {
        ESP_LOGE(TAG, "❌ Failed to communicate with %s at 0x%02X", name, addr);
    }
}

void app_main(void) {
    ESP_ERROR_CHECK(i2c_master_init());
    
    // 1. Wait for boot
    vTaskDelay(2000 / portTICK_PERIOD_MS);
    
    // 2. Run Scanner
    run_i2c_scanner();
    
    // 3. Check LSM6DSOX (Try both common addresses)
    printf("\\nChecking LSM6DSOX...\\n");
    check_sensor(LSM6DSOX_ADDR_1, LSM6DSOX_WHO_AM_I_REG, LSM6DSOX_EXPECTED_ID, "LSM6DSOX (Primary)");
    check_sensor(LSM6DSOX_ADDR_2, LSM6DSOX_WHO_AM_I_REG, LSM6DSOX_EXPECTED_ID, "LSM6DSOX (Alt)");

    // 4. Check BMP388 (Try both common addresses)
    printf("\\nChecking BMP388...\\n");
    check_sensor(BMP388_ADDR_1, BMP388_CHIP_ID_REG, BMP388_EXPECTED_ID, "BMP388 (Primary)");
    check_sensor(BMP388_ADDR_2, BMP388_CHIP_ID_REG, BMP388_EXPECTED_ID, "BMP388 (Alt)");

    while(1) {
        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }
}
"""

def generate_diagnostic():
    if not os.path.exists(PROJECT_NAME):
        os.makedirs(PROJECT_NAME)
    
    main_dir = os.path.join(PROJECT_NAME, "main")
    if not os.path.exists(main_dir):
        os.makedirs(main_dir)

    with open(os.path.join(PROJECT_NAME, "CMakeLists.txt"), "w") as f:
        f.write(CMAKE_PROJECT_TXT)

    with open(os.path.join(main_dir, "CMakeLists.txt"), "w") as f:
        f.write(CMAKE_MAIN_TXT)

    with open(os.path.join(main_dir, MAIN_FILE_NAME), "w") as f:
        f.write(MAIN_C_SOURCE)

    print(f"✅ Diagnostic tool generated in: {PROJECT_NAME}")

if __name__ == "__main__":
    generate_diagnostic()
