import os
import sys

# Configuration
PROJECT_NAME = "sensor_project"
MAIN_FILE_NAME = "main.c"

# File Contents

CMAKE_PROJECT_TXT = f"""cmake_minimum_required(VERSION 3.16)

include($ENV{{IDF_PATH}}/tools/cmake/project.cmake)
project({PROJECT_NAME})
"""

CMAKE_MAIN_TXT = """idf_component_register(SRCS "main.c"
                    INCLUDE_DIRS ".")
"""

MAIN_C_SOURCE = """
/**
 * ESP32-P4 I2C Sensor Reader (LSM6DSOX + BMP388)
 * Generated by Gemini
 *
 * Wiring Assumption:
 * - SDA: GPIO 7 (Change in definitions below if different)
 * - SCL: GPIO 8 (Change in definitions below if different)
 * - VCC: 3.3V
 * - GND: GND
 */

#include <stdio.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2c.h"
#include "esp_log.h"

static const char *TAG = "SENSOR_APP";

// ==========================================================
// I2C CONFIGURATION
// ==========================================================
// Check your board's pinout. For many P4 devkits, generic GPIOs are available.
#define I2C_MASTER_SCL_IO           8      /*!< GPIO number used for I2C master clock */
#define I2C_MASTER_SDA_IO           7      /*!< GPIO number used for I2C master data */
#define I2C_MASTER_NUM              0      /*!< I2C master i2c port number */
#define I2C_MASTER_FREQ_HZ          400000 /*!< I2C master clock frequency */
#define I2C_MASTER_TX_BUF_DISABLE   0      /*!< I2C master doesn't need buffer */
#define I2C_MASTER_RX_BUF_DISABLE   0      /*!< I2C master doesn't need buffer */

// ==========================================================
// LSM6DSOX CONSTANTS (IMU)
// ==========================================================
#define LSM6DSOX_ADDR               0x6A   // Default Address (or 0x6B)
#define LSM6DSOX_WHO_AM_I           0x0F
#define LSM6DSOX_CTRL1_XL           0x10   // Accel Config
#define LSM6DSOX_CTRL2_G            0x11   // Gyro Config
#define LSM6DSOX_OUTX_L_G           0x22   // Start of Gyro Data
#define LSM6DSOX_OUTX_L_A           0x28   // Start of Accel Data

// ==========================================================
// BMP388 CONSTANTS (Pressure/Temp)
// ==========================================================
#define BMP388_ADDR                 0x76   // Default Address (or 0x77)
#define BMP388_CHIP_ID              0x00
#define BMP388_ERR_REG              0x02
#define BMP388_STATUS               0x03
#define BMP388_DATA_0               0x04   // Pressure Data LSB
#define BMP388_PWR_CTRL             0x1B
#define BMP388_OSR                  0x1C
#define BMP388_ODR                  0x1D
#define BMP388_CALIB_DATA           0x31

// Struct to hold BMP388 Calibration Data
typedef struct {
    double par_t1;
    double par_t2;
    double par_t3;
    double par_p1;
    double par_p2;
    double par_p3;
    double par_p4;
    double par_p5;
    double par_p6;
    double par_p7;
    double par_p8;
    double par_p9;
    double par_p10;
    double par_p11;
} bmp388_calib_t;

bmp388_calib_t bmp_calib;

// ==========================================================
// I2C HELPER FUNCTIONS
// ==========================================================
static esp_err_t i2c_master_init(void) {
    int i2c_master_port = I2C_MASTER_NUM;
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_MASTER_FREQ_HZ,
    };
    i2c_param_config(i2c_master_port, &conf);
    return i2c_driver_install(i2c_master_port, conf.mode, I2C_MASTER_RX_BUF_DISABLE, I2C_MASTER_TX_BUF_DISABLE, 0);
}

static esp_err_t write_reg(uint8_t addr, uint8_t reg, uint8_t data) {
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg, true);
    i2c_master_write_byte(cmd, data, true);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

static esp_err_t read_regs(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) {
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg, true);
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_READ, true);
    if (len > 1) {
        i2c_master_read(cmd, data, len - 1, I2C_MASTER_ACK);
    }
    i2c_master_read_byte(cmd, data + len - 1, I2C_MASTER_NACK);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

// ==========================================================
// LSM6DSOX DRIVER (Simplified)
// ==========================================================
void lsm6dsox_init() {
    uint8_t who_am_i = 0;
    read_regs(LSM6DSOX_ADDR, LSM6DSOX_WHO_AM_I, &who_am_i, 1);
    if (who_am_i != 0x6C) { // 0x6C is typical ID for LSM6DSOX
        ESP_LOGE(TAG, "LSM6DSOX not found! ID: 0x%02X", who_am_i);
    } else {
        ESP_LOGI(TAG, "LSM6DSOX detected.");
    }

    // Set Accel: 52Hz, 4g scale
    write_reg(LSM6DSOX_ADDR, LSM6DSOX_CTRL1_XL, 0x38); 
    // Set Gyro: 52Hz, 2000dps
    write_reg(LSM6DSOX_ADDR, LSM6DSOX_CTRL2_G, 0x3C); 
}

void lsm6dsox_read(float *ax, float *ay, float *az, float *gx, float *gy, float *gz) {
    uint8_t raw_data[12];
    // Read 6 bytes gyro then 6 bytes accel (contiguous registers)
    read_regs(LSM6DSOX_ADDR, LSM6DSOX_OUTX_L_G, raw_data, 12);

    int16_t g_x = (int16_t)((raw_data[1] << 8) | raw_data[0]);
    int16_t g_y = (int16_t)((raw_data[3] << 8) | raw_data[2]);
    int16_t g_z = (int16_t)((raw_data[5] << 8) | raw_data[4]);

    int16_t a_x = (int16_t)((raw_data[7] << 8) | raw_data[6]);
    int16_t a_y = (int16_t)((raw_data[9] << 8) | raw_data[8]);
    int16_t a_z = (int16_t)((raw_data[11] << 8) | raw_data[10]);

    // Conversion factors based on config
    *ax = (float)a_x * 0.122f; // mg/LSB for 4g
    *ay = (float)a_y * 0.122f;
    *az = (float)a_z * 0.122f;
    
    *gx = (float)g_x * 70.0f; // mdps/LSB for 2000dps
    *gy = (float)g_y * 70.0f;
    *gz = (float)g_z * 70.0f;
}

// ==========================================================
// BMP388 DRIVER (Simplified with Compensation)
// ==========================================================
// Helper to combine bytes
uint16_t concat_u16(uint8_t msb, uint8_t lsb) { return (uint16_t)((msb << 8) | lsb); }

void bmp388_get_calib_data() {
    uint8_t cal[21];
    read_regs(BMP388_ADDR, BMP388_CALIB_DATA, cal, 21);

    // Parse according to Bosch Datasheet
    uint16_t t1 = concat_u16(cal[1], cal[0]);
    uint16_t t2 = concat_u16(cal[3], cal[2]);
    int8_t t3 = (int8_t)cal[4];
    int16_t p1 = (int16_t)concat_u16(cal[6], cal[5]);
    int16_t p2 = (int16_t)concat_u16(cal[8], cal[7]);
    int8_t p3 = (int8_t)cal[9];
    int8_t p4 = (int8_t)cal[10];
    uint16_t p5 = concat_u16(cal[12], cal[11]);
    uint16_t p6 = concat_u16(cal[14], cal[13]);
    int8_t p7 = (int8_t)cal[15];
    int8_t p8 = (int8_t)cal[16];
    int16_t p9 = (int16_t)concat_u16(cal[18], cal[17]);
    int8_t p10 = (int8_t)cal[19];
    int8_t p11 = (int8_t)cal[20];

    // Convert to floating point params
    bmp_calib.par_t1 = (double)t1 / pow(2.0, -8.0);
    bmp_calib.par_t2 = (double)t2 / pow(2.0, 30.0);
    bmp_calib.par_t3 = (double)t3 / pow(2.0, 48.0);
    bmp_calib.par_p1 = (double)(p1 - 16384) / pow(2.0, 20.0);
    bmp_calib.par_p2 = (double)(p2 - 16384) / pow(2.0, 29.0);
    bmp_calib.par_p3 = (double)p3 / pow(2.0, 32.0);
    bmp_calib.par_p4 = (double)p4 / pow(2.0, 37.0);
    bmp_calib.par_p5 = (double)p5 / pow(2.0, -3.0);
    bmp_calib.par_p6 = (double)p6 / pow(2.0, 6.0);
    bmp_calib.par_p7 = (double)p7 / pow(2.0, 8.0);
    bmp_calib.par_p8 = (double)p8 / pow(2.0, 15.0);
    bmp_calib.par_p9 = (double)p9 / pow(2.0, 48.0);
    bmp_calib.par_p10 = (double)p10 / pow(2.0, 48.0);
    bmp_calib.par_p11 = (double)p11 / pow(2.0, 65.0);
}

void bmp388_init() {
    uint8_t chip_id = 0;
    read_regs(BMP388_ADDR, BMP388_CHIP_ID, &chip_id, 1);
    if (chip_id != 0x50) {
        ESP_LOGE(TAG, "BMP388 not found! ID: 0x%02X", chip_id);
    } else {
        ESP_LOGI(TAG, "BMP388 detected.");
    }
    
    bmp388_get_calib_data();

    // Power Control: Enable Pressure and Temp sensors, Normal Mode
    write_reg(BMP388_ADDR, BMP388_PWR_CTRL, 0x33); 
    // OSR: P x4, T x2
    write_reg(BMP388_ADDR, BMP388_OSR, 0x02); 
    // ODR: 50Hz
    write_reg(BMP388_ADDR, BMP388_ODR, 0x02); 
}

void bmp388_read(double *temperature, double *pressure) {
    uint8_t data[6];
    read_regs(BMP388_ADDR, BMP388_DATA_0, data, 6);

    uint32_t adc_p = (data[2] << 16) | (data[1] << 8) | data[0];
    uint32_t adc_t = (data[5] << 16) | (data[4] << 8) | data[3];

    // Compensation Math (Bosch Algorithm)
    double partial_data1;
    double partial_data2;
    double partial_data3;
    double partial_data4;
    double partial_data5;
    double partial_data6;

    // Temperature
    partial_data1 = (double)(adc_t - bmp_calib.par_t1);
    partial_data2 = (double)(partial_data1 * bmp_calib.par_t2);
    *temperature = partial_data2 + (partial_data1 * partial_data1) * bmp_calib.par_t3;

    // Pressure
    partial_data1 = bmp_calib.par_p6 * *temperature;
    partial_data2 = bmp_calib.par_p7 * (*temperature * *temperature);
    partial_data3 = bmp_calib.par_p8 * (*temperature * *temperature * *temperature);
    partial_data4 = bmp_calib.par_p5 + partial_data1 + partial_data2 + partial_data3;

    partial_data1 = bmp_calib.par_p2 * *temperature;
    partial_data2 = bmp_calib.par_p3 * (*temperature * *temperature);
    partial_data3 = bmp_calib.par_p4 * (*temperature * *temperature * *temperature);
    partial_data5 = (double)adc_p * (bmp_calib.par_p1 + partial_data1 + partial_data2 + partial_data3);

    partial_data1 = (double)adc_p * (double)adc_p;
    partial_data2 = bmp_calib.par_p9 + bmp_calib.par_p10 * *temperature;
    partial_data3 = partial_data1 * partial_data2;
    partial_data6 = partial_data3 + ((double)adc_p * (double)adc_p * (double)adc_p) * bmp_calib.par_p11;

    *pressure = partial_data4 + partial_data5 + partial_data6;
    *pressure = *pressure / 100.0; // Convert Pa to hPa
}

// ==========================================================
// MAIN APPLICATION
// ==========================================================
void app_main(void) {
    ESP_LOGI(TAG, "Starting Sensor Reader on ESP32-P4");
    
    ESP_ERROR_CHECK(i2c_master_init());
    
    // Give sensors a moment to power up
    vTaskDelay(100 / portTICK_PERIOD_MS);
    
    lsm6dsox_init();
    bmp388_init();

    float ax, ay, az, gx, gy, gz;
    double temp, press;

    while (1) {
        lsm6dsox_read(&ax, &ay, &az, &gx, &gy, &gz);
        bmp388_read(&temp, &press);

        // Output CSV style for easy plotting
        // Format: Accel(mg), Gyro(mdps), Temp(C), Press(hPa)
        printf("IMU: Ax:%.2f Ay:%.2f Az:%.2f Gx:%.2f Gy:%.2f Gz:%.2f | ENV: T:%.2f C P:%.2f hPa\\n", 
               ax, ay, az, gx, gy, gz, temp, press);

        vTaskDelay(100 / portTICK_PERIOD_MS); // 10Hz Output
    }
}
"""

def generate_project():
    # Create Directories
    if not os.path.exists(PROJECT_NAME):
        os.makedirs(PROJECT_NAME)
    
    main_dir = os.path.join(PROJECT_NAME, "main")
    if not os.path.exists(main_dir):
        os.makedirs(main_dir)

    # Write Root CMakeLists.txt
    with open(os.path.join(PROJECT_NAME, "CMakeLists.txt"), "w") as f:
        f.write(CMAKE_PROJECT_TXT)

    # Write Main CMakeLists.txt
    with open(os.path.join(main_dir, "CMakeLists.txt"), "w") as f:
        f.write(CMAKE_MAIN_TXT)

    # Write main.c
    with open(os.path.join(main_dir, MAIN_FILE_NAME), "w") as f:
        f.write(MAIN_C_SOURCE)

    print(f"âœ… Success! Project generated in folder: {PROJECT_NAME}")
    print("Next steps:")
    print(f"1. cd {PROJECT_NAME}")
    print("2. idf.py set-target esp32p4")
    print("3. idf.py build flash monitor")

if __name__ == "__main__":
    generate_project()
